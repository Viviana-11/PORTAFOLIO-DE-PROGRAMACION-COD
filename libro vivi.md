---
title: ""
output: 
  pdf_document:
    toc: false
    number_sections: false
    keep_tex: true
  html_document:
    toc: false
    number_sections: false
    theme: cerulean
    df_print: paged
    css: estilos.css
---

<div style="text-align: center; page-break-after: avoid;">

<table width="100%" style="border: none;">
  <tr>
    <td width="20%" align="left">
      <img src="Logo unap.png" alt="Logo Izquierdo" width="120">
    </td>
    <td width="60%" align="center">
      <h1 style="color:#00509d; font-family:Arial, sans-serif;">UNIVERSIDAD NACIONAL DEL ALTIPLANO - PUNO</h1>
      <h2 style="color:#003f88; font-family:Arial, sans-serif;">FACULTAD DE INGENIER√çA ESTAD√çSTICA E INFORM√ÅTICA</h2>
      <h3 style="color:#0077b6; font-family:Arial, sans-serif;">C√ìDIGOS DE PROGRAMACI√ìN - ESTRUCTURA DE DATOS</h3>
    </td>
    <td width="20%" align="right">
      <img src="FINESI.png" alt="Logo Derecho" width="120">
    </td>
  </tr>
  
</table>
<br><br>
<!-- Aqu√≠ agregas la imagen -->
<div style="text-align: center;">
  <img src="programacion .png" alt="Imagen portada" width="300*500" />
</div>

<h2 style="color:#03045e; font-family:Arial, sans-serif;">LIBRO DE PROGRAMACI√ìN</h2>

<br>
<p style="font-size:18px;"><strong>Alumno:</strong> Quisbert Quispe Viviana Mary</p>
<p style="font-size:18px;"><strong>Curso:</strong> Estructura de Datos</p>
<p style="font-size:18px;"><strong>Docente:</strong> Fred Torres Cruz</p>
<p style="font-size:18px;"><strong>Fecha:</strong> 29 de mayo de 2025</p>

<div style="position: relative; border: none;">
  <!-- Frase en esquina inferior derecha -->
  <div style="position: absolute; bottom: 10px; right: 10px; 
              font-style: italic; font-size: 16px; color: #0077b6;">
    "Aprende a programar, crea el mundo que imaginas."
  </div>
</div>


## √çndice

- [Introducci√≥n ‚Äì ¬øQu√© es programar?](capitulos/00-introduccion.md)

### üß± PARTE 1: Bases de la programaci√≥n

- [Cap√≠tulo 1 ‚Äì Primeros pasos: tu primer programa](capitulos/01-primer-programa.md)
- [Cap√≠tulo 2 ‚Äì Variables, tipos de datos y entrada/salida](capitulos/02-variables.md)
- [Cap√≠tulo 3 ‚Äì Operadores y expresiones](capitulos/03-operadores.md)
- [Cap√≠tulo 4 ‚Äì Estructuras de control: if, if-else, switch](capitulos/04-control.md)

### üîÅ PARTE 2: Todos los bucles

- [Cap√≠tulo 5 ‚Äì Bucle while: repite mientras algo sea cierto](capitulos/05-while.md)
- [Cap√≠tulo 6 ‚Äì Bucle do-while: haz al menos una vez](capitulos/06-do-while.md)
- [Cap√≠tulo 7 ‚Äì Bucle for: repite con conteo claro](capitulos/07-for.md)
- [Cap√≠tulo 8 ‚Äì Bucles anidados y control de bucles (break, continue)](capitulos/08-anidados.md)

### üì¶ PARTE 3: Datos estructurados

- [Cap√≠tulo 9 ‚Äì Arreglos (arrays): muchas variables en una sola](capitulos/09-arreglos.md)
- [Cap√≠tulo 10 ‚Äì Cadenas de texto: arrays de caracteres](capitulos/10-cadenas.md)
- [Cap√≠tulo 11 ‚Äì Estructuras (struct): tus propios tipos de datos](capitulos/11-struct.md)

### üîó PARTE 4: Estructuras de datos din√°micas

- [Cap√≠tulo 12 ‚Äì Punteros: direcciones y memoria](capitulos/12-punteros.md)
- [Cap√≠tulo 13 ‚Äì Listas enlazadas](capitulos/13-lista-enlazada.md)
- [Cap√≠tulo 14 ‚Äì Listas doblemente enlazadas](capitulos/14-lista-doble.md)
- [Cap√≠tulo 15 ‚Äì Listas circulares](capitulos/15-lista-circular.md)

### üìö PARTE 5: Pilas, colas y recursi√≥n

- [Cap√≠tulo 16 ‚Äì Pilas (Stacks): √∫ltimo en entrar, primero en salir](capitulos/16-pilas.md)
- [Cap√≠tulo 17 ‚Äì Colas (Queues): primero en entrar, primero en salir](capitulos/17-colas.md)
- [Cap√≠tulo 18 ‚Äì Colas circulares](capitulos/18-colas-circulares.md)
- [Cap√≠tulo 19 ‚Äì Recursi√≥n: funciones que se llaman a s√≠ mismas](capitulos/19-recursion.md)



</div>
<div style="page-break-after: always;"></div>

### [Introducci√≥n ‚Äì ¬øQu√© es programar ?

Programar en C++ es el proceso de escribir instrucciones en el lenguaje de programaci√≥n C++ para indicarle a una computadora exactamente qu√© debe hacer y en qu√© orden. Estas instrucciones deben ser claras, precisas y l√≥gicas, ya que la computadora no puede adivinar ni interpretar como lo har√≠a una persona.

Programar es como ense√±arle a una m√°quina c√≥mo realizar una tarea, paso a paso, tal como lo har√≠as con un robot.

üß† Ejemplo cotidiano: el robot que hace t√©
Imagina que tienes un robot, y quieres que prepare una taza de t√©. Para que lo haga correctamente, debes darle las instrucciones en el orden correcto. Ser√≠a algo as√≠:

Calentar agua

Colocar una bolsa de t√© en la taza

Verter el agua caliente en la taza

Esperar 3 minutos

Sacar la bolsa

Servir

Estas instrucciones deben ser exactas. Si no le dices al robot que caliente el agua antes de verterla, por ejemplo, el t√© no saldr√° bien. Lo mismo ocurre cuando se programa: cada paso importa y debe estar bien pensado.





### üß± PARTE 1: Bases de la programaci√≥n

## üöÄ Primeros pasos para tu primer programa

Crear tu primer programa en C++ es m√°s f√°cil de lo que parece. Aqu√≠ te explico paso a paso c√≥mo hacerlo desde cero.

### üß∞ 1. Prepara tus herramientas

Antes de programar, necesitas tener lo siguiente:

- Un editor de texto o entorno de desarrollo (IDE). Puedes usar:
  - **Code::Blocks**
  - **Dev-C++**
  - **Visual Studio Code**
  - **Replit (en l√≠nea)**

- Un compilador de C++, como **g++** (viene con Code::Blocks y otras IDEs).

---

### ‚úçÔ∏è 2. Escribe tu primer programa

Abre tu editor y escribe el siguiente c√≥digo:

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hola, mundo" << endl;
    return 0;
}
```


### L√≠nea 1: `#include <iostream>`

Esta l√≠nea le dice al programa que queremos usar la librer√≠a **iostream**, que contiene las herramientas necesarias para mostrar texto en pantalla (como `cout`) y leer datos del teclado.



### L√≠nea 2: `using namespace std;`

Aqu√≠ indicamos que vamos a usar el **espacio de nombres est√°ndar** (std). Esto nos permite escribir simplemente `cout` en lugar de `std::cout`.


### L√≠nea 3: `int main() {`

Esta es la funci√≥n principal llamada `main`. Es el punto de inicio de cualquier programa en C++. Cuando ejecutas tu programa, lo primero que hace la computadora es entrar a esta funci√≥n y ejecutar las instrucciones que est√°n dentro de ella.



### L√≠nea 4: `cout << "Hola, mundo" << endl;`

* `cout` es la instrucci√≥n que env√≠a informaci√≥n a la pantalla (consola).
* `<<` es el operador que direcciona lo que queremos mostrar hacia `cout`.
* `"Hola, mundo"` es el texto que queremos que aparezca.
* `endl` significa **end line** (fin de l√≠nea), que hace un salto de l√≠nea para que cualquier cosa que se imprima despu√©s salga en una l√≠nea nueva.
* La l√≠nea termina con `;` que indica el fin de la instrucci√≥n.

Esta l√≠nea hace que en la pantalla aparezca:

```
Hola, mundo
```


### L√≠nea 5: `return 0;`

Con esta instrucci√≥n le decimos al sistema que el programa termin√≥ correctamente. El n√∫mero `0` es un c√≥digo que representa √©xito.



### L√≠nea 6: `}`

Esta llave cierra la funci√≥n `main`, indicando que no hay m√°s instrucciones para ejecutar.




# üìò Cap√≠tulo 2 ‚Äì Variables, tipos de datos y entrada/salida

En este cap√≠tulo aprender√°s tres cosas muy importantes para todo lenguaje de programaci√≥n:

1. Qu√© son las **variables**
2. Qu√© tipos de datos existen
3. C√≥mo interactuar con el usuario usando **entrada (`cin`)** y **salida (`cout`)**.

---

## üîê ¬øQu√© es una variable?

Una **variable** es un espacio en la memoria de la computadora donde se guarda un dato que puede cambiar durante la ejecuci√≥n del programa.  

Es como una cajita con nombre, donde puedes guardar valores.

### ‚ú≥Ô∏è Ejemplo:
```cpp
int edad = 18;
```

Aqu√≠:

int indica que es un n√∫mero entero.

edad es el nombre de la variable.

18 es el valor que estamos guardando en esa variable.

üßÆ Tipos de datos en C++
Cada variable debe tener un tipo de dato, que define qu√© tipo de informaci√≥n va a guardar. Aqu√≠ tienes los m√°s usados:

| Tipo de dato | Significado                              | Ejemplo de uso               |
|--------------|-------------------------------------------|------------------------------|
| `int`        | N√∫mero entero                             | `int edad = 20;`             |
| `float`      | N√∫mero decimal corto                      | `float peso = 48.5;`         |
| `double`     | N√∫mero decimal largo (m√°s preciso)        | `double pi = 3.1416;`        |
| `char`       | Un solo car√°cter                          | `char letra = 'A';`          |
| `string`     | Cadena de texto (palabras o frases)       | `string nombre = "Jhonatan";`|
| `bool`       | Valor l√≥gico: verdadero o falso           | `bool activo = true;`        |


üîß Nota: Para usar string, debes incluir la librer√≠a #include <string>



## üîÑ Entrada y salida de datos

Para que un programa sea √∫til, debe poder **recibir datos** (entrada) y **mostrar resultados** (salida).

### Entrada: `cin`

Usamos `cin` para pedir al usuario que escriba datos en la consola.

```cpp
int edad;
cout << "Escribe tu edad: ";
cin >> edad;
```

### Salida: `cout`

Usamos `cout` para mostrar mensajes o resultados en la pantalla.

```cpp
cout << "Tu edad es: " << edad << endl;
```

---

## üß© Ejemplo completo

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string nombre;
    int edad;

    cout << "Escribe tu nombre: ";
    getline(cin, nombre);  // Leer texto con espacios

    cout << "Escribe tu edad: ";
    cin >> edad;

    cout << "Hola " << nombre << ", tienes " << edad << " a√±os." << endl;

    return 0;
}
```


# üßÆ Cap√≠tulo 3 ‚Äì Operadores y expresiones

En este cap√≠tulo aprender√°s a usar **operadores** en C++, que son los s√≠mbolos que permiten realizar operaciones matem√°ticas, comparaciones y manipulaciones entre datos.

---

## üìå ¬øQu√© es un operador?

Un **operador** es un s√≠mbolo que le dice a la computadora qu√© operaci√≥n debe realizar con uno o m√°s valores (tambi√©n llamados operandos).

Por ejemplo:

```cpp
int suma = 5 + 3;
```
üî¢ Tipos de operadores en C++
1. üßÆ Operadores aritm√©ticos
Se usan para operaciones matem√°ticas b√°sicas:

| Operador | Significado       | Ejemplo   | Resultado |
|----------|-------------------|-----------|-----------|
| +        | Suma              | 5 + 2     | 7         |
| -        | Resta             | 5 - 2     | 3         |
| *        | Multiplicaci√≥n    | 5 * 2     | 10        |
| /        | Divisi√≥n          | 10 / 2    | 5         |
| %        | M√≥dulo (residuo)  | 10 % 3    | 1         |


1. üîç Operadores de comparaci√≥n
Se usan para comparar dos valores. El resultado siempre es true o false (booleano).

| Operador | Significado         | Ejemplo    | Resultado |
|----------|---------------------|------------|-----------|
| ==       | Igual a             | 5 == 5     | true      |
| !=       | Distinto de         | 5 != 3     | true      |
| >        | Mayor que           | 5 > 3      | true      |
| <        | Menor que           | 3 < 5      | true      |
| >=       | Mayor o igual que   | 5 >= 5     | true      |
| <=       | Menor o igual que   | 3 <= 5     | true      |


1. üîó Operadores l√≥gicos
Se usan para combinar condiciones l√≥gicas:

| Operador | Significado      | Ejemplo          | Resultado |
|----------|------------------|------------------|-----------|
| `&&`     | Y l√≥gico (AND)   | `true && false`  | `false`   |
| `\|\|`   | O l√≥gico (OR)    | `true || false`  | `true`    |
| `!`      | Negaci√≥n (NOT)   | `!true`          | `false`   |

4. üß∞ Operadores de asignaci√≥n
Se usan para asignar valores a variables.

| Operador | Ejemplo   | Equivalente a...   |
|----------|-----------|--------------------|
| `=`      | `x = 10;` | Asignar 10 a `x`   |
| `+=`     | `x += 5;` | `x = x + 5`        |
| `-=`     | `x -= 2;` | `x = x - 2`        |
| `*=`     | `x *= 3;` | `x = x * 3`        |
| `/=`     | `x /= 2;` | `x = x / 2`        |
| `%=`     | `x %= 4;` | `x = x % 4`        |






# Cap√≠tulo 4 ‚Äì Estructuras de control: if, if-else, switch

## ¬øQu√© son las estructuras de control?

Cuando programas, a veces quieres que el computador tome decisiones, como t√∫ lo har√≠as. Por ejemplo: ‚ÄúSi hace fr√≠o, me pongo abrigo; si no, me pongo una camiseta.‚Äù En programaci√≥n, esas decisiones las hacemos con **estructuras de control**.

En C++, las m√°s usadas para decidir qu√© hacer son: `if`, `if-else` y `switch`.

---

## 1. La estructura `if`

### ¬øPara qu√© sirve?

Para decirle al programa: ‚ÄúHaz algo solo si se cumple una condici√≥n.‚Äù

### ¬øC√≥mo funciona?

El programa revisa una condici√≥n (como si una pregunta fuera verdadera o falsa). Si es verdadera, hace lo que le dices. Si no, no hace nada.

### Ejemplo sencillo

```cpp
int edad = 18;

if (edad >= 18) {
    std::cout << "Eres mayor de edad." << std::endl;
}
```

**¬øQu√© pasa aqu√≠?**
Si la edad es 18 o m√°s, el programa mostrar√° el mensaje ‚ÄúEres mayor de edad.‚Äù Si no, simplemente no pasa nada y sigue.

---

## 2. La estructura `if-else`

### ¬øPara qu√© sirve?

Para darle al programa dos caminos: uno si la condici√≥n es cierta, y otro si es falsa.

### ¬øC√≥mo funciona?

Si la condici√≥n es verdadera, hace una cosa. Si es falsa, hace otra.

### Ejemplo f√°cil

```cpp
int edad = 16;

if (edad >= 18) {
    std::cout << "Eres mayor de edad." << std::endl;
} else {
    std::cout << "Eres menor de edad." << std::endl;
}
```

**¬øQu√© hace el programa?**
Si tienes 18 a√±os o m√°s, muestra que eres mayor. Si no, te dice que eres menor. ¬°As√≠ de simple!

---

## 3. La estructura `switch`

### ¬øPara qu√© sirve?

Cuando tienes varias opciones y quieres que el programa elija una seg√∫n el valor de una variable.

### ¬øC√≥mo funciona?

El programa mira el valor y compara con cada opci√≥n (llamadas `case`). Cuando encuentra la opci√≥n correcta, hace lo que le dices y se detiene.

Si ninguna opci√≥n coincide, hace algo por defecto.

### Ejemplo pr√°ctico

```cpp
char opcion = 'B';

switch (opcion) {
    case 'A':
        std::cout << "Elegiste la opci√≥n A." << std::endl;
        break;
    case 'B':
        std::cout << "Elegiste la opci√≥n B." << std::endl;
        break;
    case 'C':
        std::cout << "Elegiste la opci√≥n C." << std::endl;
        break;
    default:
        std::cout << "Opci√≥n no v√°lida." << std::endl;
}
```

**¬øQu√© pasa aqu√≠?**
Si la opci√≥n es ‚ÄòA‚Äô, ‚ÄòB‚Äô o ‚ÄòC‚Äô, muestra el mensaje correspondiente. Si no es ninguna de esas, muestra que la opci√≥n no es v√°lida.





### üîÅ PARTE 2: Todos los bucles



# Cap√≠tulo 5 ‚Äì Bucle while: repite mientras algo sea cierto

## ¬øQu√© es un bucle `while`?

Un **bucle `while`** es una estructura de control que le dice a la computadora:
**‚ÄúRepite un grupo de instrucciones mientras una condici√≥n sea verdadera.‚Äù**

Es como decirle a alguien:
*Mientras la luz est√© verde, sigue caminando.*
Cuando la luz cambie a rojo, deja de caminar.



## ¬øC√≥mo funciona?

1. Primero, el programa verifica la condici√≥n que le diste.
2. Si la condici√≥n es verdadera (`true`), ejecuta el c√≥digo dentro del bucle.
3. Despu√©s de ejecutar ese c√≥digo, vuelve a revisar la condici√≥n.
4. Mientras la condici√≥n siga siendo verdadera, seguir√° repitiendo el c√≥digo.
5. Cuando la condici√≥n se vuelve falsa (`false`), el programa sale del bucle y contin√∫a con lo que sigue.



## Ejemplo simple

```cpp
int contador = 1;

while (contador <= 5) {
    std::cout << "N√∫mero: " << contador << std::endl;
    contador++;  // Suma 1 al contador en cada vuelta
}
```

**¬øQu√© hace este c√≥digo?**

* Empieza con `contador` igual a 1.
* Mientras `contador` sea menor o igual a 5, imprime el n√∫mero.
* Despu√©s suma 1 al contador.
* Cuando el contador llegue a 6, la condici√≥n ya no se cumple y el bucle termina.

**Salida en pantalla:**

```
N√∫mero: 1
N√∫mero: 2
N√∫mero: 3
N√∫mero: 4
N√∫mero: 5
```

---

# Cap√≠tulo 6 ‚Äì Bucle do-while: haz al menos una vez

## ¬øQu√© es un bucle `do-while`?

El **bucle `do-while`** es muy parecido al `while`, pero con una diferencia importante:
**El c√≥digo dentro del bucle se ejecuta al menos una vez, antes de verificar la condici√≥n.**

Es como cuando pruebas un plato nuevo y solo despu√©s decides si te gusta o no. Primero lo pruebas (ejecutas el c√≥digo), luego decides si seguir o parar (eval√∫as la condici√≥n).

---

## ¬øC√≥mo funciona?

1. El programa primero ejecuta el c√≥digo que est√° dentro del bloque `do`.
2. Despu√©s, verifica la condici√≥n que est√° en el `while`.
3. Si la condici√≥n es verdadera (`true`), vuelve a ejecutar el bloque `do`.
4. Si la condici√≥n es falsa (`false`), el programa sale del bucle y sigue con lo que sigue.

---

## Ejemplo sencillo

```cpp
int contador = 1;

do {
    std::cout << "N√∫mero: " << contador << std::endl;
    contador++;  // Suma 1 al contador en cada vuelta
} while (contador <= 5);
```

**¬øQu√© hace este c√≥digo?**

* Primero imprime el n√∫mero aunque sea la primera vez.
* Despu√©s revisa si `contador` es menor o igual a 5.
* Mientras la condici√≥n sea verdadera, sigue repitiendo el c√≥digo.
* Cuando `contador` es 6, el bucle termina.

**Salida en pantalla:**

```
N√∫mero: 1
N√∫mero: 2
N√∫mero: 3
N√∫mero: 4
N√∫mero: 5
```




# Cap√≠tulo 7 ‚Äì Bucle for: repite con conteo claro

## ¬øQu√© es un bucle `for`?

El **bucle `for`** es otra forma de repetir un conjunto de instrucciones, pero es ideal cuando sabes cu√°ntas veces quieres repetir algo.

Piensa en contar pasos: *‚ÄúVoy a dar 10 pasos.‚Äù* Aqu√≠ sabes desde el principio cu√°ntas veces vas a repetir la acci√≥n.



## ¬øC√≥mo funciona?

Un bucle `for` tiene tres partes muy claras:

1. **Inicio:** donde defines una variable que controla el conteo (por ejemplo, `i = 1`).
2. **Condici√≥n:** la regla que debe cumplirse para que el bucle siga (por ejemplo, `i <= 10`).
3. **Actualizaci√≥n:** c√≥mo cambia la variable en cada repetici√≥n (por ejemplo, `i++`, que suma 1 cada vez).

La estructura b√°sica es as√≠:

```cpp
for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
    // C√≥digo que quieres repetir
}
```

---

## Ejemplo simple

```cpp
for (int i = 1; i <= 5; i++) {
    std::cout << "N√∫mero: " << i << std::endl;
}
```

**¬øQu√© hace este c√≥digo?**

* Empieza con `i` igual a 1.
* Mientras `i` sea menor o igual a 5, imprime el n√∫mero.
* Luego suma 1 a `i`.
* Cuando `i` llega a 6, el bucle termina.

**Salida en pantalla:**

```
N√∫mero: 1
N√∫mero: 2
N√∫mero: 3
N√∫mero: 4
N√∫mero: 5
```



El bucle `for` es muy usado porque organiza todo el conteo en una sola l√≠nea y es f√°cil de leer.




---

# Cap√≠tulo 8 ‚Äì Bucles anidados y control de bucles (break, continue)

## ¬øQu√© son los bucles anidados?

Los **bucles anidados** son bucles dentro de otros bucles.
Es como cuando haces un recorrido por una cuadr√≠cula: primero recorres las filas, y dentro de cada fila recorres las columnas.

### ¬øPara qu√© sirven?

Sirven cuando necesitas hacer tareas repetitivas en dos (o m√°s) niveles. Por ejemplo: imprimir una tabla, recorrer una matriz, o hacer combinaciones.

---

## Ejemplo de bucles anidados

```cpp
for (int fila = 1; fila <= 3; fila++) {
    for (int columna = 1; columna <= 4; columna++) {
        std::cout << "Fila " << fila << ", Columna " << columna << std::endl;
    }
}
```

**¬øQu√© hace este c√≥digo?**

* Primero, recorre las filas de 1 a 3.
* Por cada fila, recorre las columnas de 1 a 4.
* Imprime la posici√≥n fila-columna en cada paso.

---

## Control de bucles con `break` y `continue`

A veces quieres controlar mejor cu√°ndo salir o saltarte partes de un bucle.

### 1. `break`

El comando `break` detiene completamente el bucle, saliendo de √©l sin importar si la condici√≥n sigue siendo verdadera.

#### Ejemplo:

```cpp
for (int i = 1; i <= 10; i++) {
    if (i == 5) {
        break;  // Sale del bucle cuando i es 5
    }
    std::cout << i << std::endl;
}
```

**Salida:**

```
1
2
3
4
```

Cuando llega a 5, el bucle termina y no imprime m√°s n√∫meros.

---

### 2. `continue`

El comando `continue` salta la vuelta actual del bucle y pasa directamente a la siguiente repetici√≥n.

#### Ejemplo:

```cpp
for (int i = 1; i <= 5; i++) {
    if (i == 3) {
        continue;  // Salta el n√∫mero 3
    }
    std::cout << i << std::endl;
}
```

**Salida:**

```
1
2
4
5
```

Cuando `i` es 3, el programa no imprime nada y sigue con el siguiente n√∫mero.






# Cap√≠tulo 9 ‚Äì Arreglos (arrays): muchas variables en una sola

## ¬øQu√© es un arreglo (array)?

Un **arreglo** es una estructura que permite guardar varias variables del mismo tipo en un solo lugar bajo un mismo nombre.
Es como una fila de cajas numeradas donde puedes guardar informaci√≥n similar. Cada caja tiene una posici√≥n llamada **√≠ndice**, que empieza desde 0.



## ¬øPara qu√© sirven los arreglos?

Cuando tienes muchos datos relacionados, por ejemplo las notas de varios estudiantes o los precios de productos, en lugar de crear una variable para cada dato, usas un arreglo para tenerlos organizados y poder acceder a ellos f√°cilmente con un √≠ndice.


## ¬øC√≥mo se declara un arreglo en C++?

Para crear un arreglo necesitas indicar:

* El tipo de dato que almacenar√° (por ejemplo, `int`, `char`, `float`).
* El nombre del arreglo.
* La cantidad de elementos que tendr√° (su tama√±o).

Ejemplo:

```cpp
int numeros[5];  // Arreglo de 5 n√∫meros enteros
```



## ¬øC√≥mo se accede a los elementos?

Cada elemento tiene un √≠ndice empezando en 0. Para acceder o modificar un valor, usas el nombre del arreglo con el √≠ndice entre corchetes:

```cpp
numeros[0] = 10;  // Asigna 10 al primer elemento
int x = numeros[2];  // Lee el tercer elemento
```


## Ejemplo completo

```cpp
#include <iostream>
using namespace std;

int main() {
    int edades[4];  // Arreglo para 4 edades

    edades[0] = 18;
    edades[1] = 20;
    edades[2] = 22;
    edades[3] = 19;

    for (int i = 0; i < 4; i++) {
        cout << "Edad en la posici√≥n " << i << ": " << edades[i] << endl;
    }

    return 0;
}
```

### Explicaci√≥n:

* Se declara un arreglo llamado `edades` con 4 posiciones.
* Se asignan valores a cada posici√≥n del arreglo.
* Se usa un bucle `for` para recorrer el arreglo e imprimir cada edad junto a su posici√≥n.

### Salida del programa:

```
Edad en la posici√≥n 0: 18
Edad en la posici√≥n 1: 20
Edad en la posici√≥n 2: 22
Edad en la posici√≥n 3: 19
```
# Cap√≠tulo 10 ‚Äì Cadenas de texto: arrays de caracteres

## ¬øQu√© es una cadena de texto?

Una **cadena de texto** es una secuencia de caracteres que forman palabras, frases o cualquier texto.
En C++, las cadenas tradicionales se representan como **arrays de caracteres**, es decir, una lista de letras, n√∫meros o s√≠mbolos, uno al lado del otro.



## ¬øC√≥mo funciona una cadena de texto en C++?

* Cada car√°cter de la cadena es un elemento del arreglo (array) de tipo `char`.
* La cadena termina con un car√°cter especial llamado **car√°cter nulo** (`'\0'`), que indica el final del texto.
* Por ejemplo, la palabra `"Hola"` se almacena como un arreglo con los caracteres `'H'`, `'o'`, `'l'`, `'a'` y `'\0'` al final.



## ¬øC√≥mo se declara una cadena de texto?

Se declara como un arreglo de `char` con un tama√±o suficiente para guardar todos los caracteres m√°s el car√°cter nulo.

Ejemplo:

```cpp
char saludo[6] = {'H', 'o', 'l', 'a', '!', '\0'};
```

O tambi√©n se puede declarar as√≠, que es m√°s com√∫n y pr√°ctico:

```cpp
char saludo[] = "Hola!";
```



## ¬øC√≥mo se usa una cadena de texto?

Puedes acceder a cada car√°cter usando su √≠ndice, igual que en los arreglos normales.

Ejemplo:

```cpp
cout << saludo[0];  // Imprime 'H'
cout << saludo[4];  // Imprime '!'
```



## Ejemplo completo

```cpp
#include <iostream>
using namespace std;

int main() {
    char nombre[] = "Viviana";

    cout << "Mi nombre es: " << nombre << endl;

    // Mostrar cada car√°cter uno por uno
    for (int i = 0; nombre[i] != '\0'; i++) {
        cout << "Caracter en posici√≥n " << i << ": " << nombre[i] << endl;
    }

    return 0;
}
```

### Explicaci√≥n:

* Se crea una cadena `nombre` con el texto `"Marisol"`.
* Se imprime la cadena completa.
* Luego, con un bucle `for` se recorren y muestran todos los caracteres hasta encontrar el car√°cter nulo (`'\0'`), que indica el final.

### Salida del programa:

```
Mi nombre es: Marisol
Caracter en posici√≥n 0: M
Caracter en posici√≥n 1: a
Caracter en posici√≥n 2: r
Caracter en posici√≥n 3: i
Caracter en posici√≥n 4: s
Caracter en posici√≥n 5: o
Caracter en posici√≥n 6: l
```




# Cap√≠tulo 11 ‚Äì Estructuras (`struct`): tus propios tipos de datos

## üß© ¬øQu√© es una estructura (`struct`)?

Una **estructura** en C++ te permite crear **tu propio tipo de dato** combinando varios datos de distintos tipos bajo un mismo nombre. Es como dise√±ar un "molde" para representar algo m√°s complejo, como una persona, un libro o un producto.



## üì¶ ¬øPara qu√© sirve?

Imagina que quieres guardar informaci√≥n de un estudiante: su nombre, edad y promedio. Podr√≠as usar tres variables separadas, pero eso puede volverse desordenado.

Con `struct`, puedes agrupar todo en una sola unidad:

```cpp
struct Estudiante {
    string nombre;
    int edad;
    float promedio;
};
```



## üõ† ¬øC√≥mo se usa?

### 1. **Definir la estructura** (normalmente fuera del `main`):

```cpp
struct Estudiante {
    string nombre;
    int edad;
    float promedio;
};
```

### 2. **Declarar variables del tipo estructurado**:

```cpp
Estudiante alumno1;
```

### 3. **Asignar valores a los campos**:

```cpp
alumno1.nombre = "manuela ";
alumno1.edad = 18;
alumno1.promedio = 16.5;
```

### 4. **Mostrar la informaci√≥n**:

```cpp
cout << "Nombre: " << alumno1.nombre << endl;
cout << "Edad: " << alumno1.edad << endl;
cout << "Promedio: " << alumno1.promedio << endl;
```



## üß† Ejemplo completo

```cpp
#include <iostream>
using namespace std;

// Definimos una estructura llamada Estudiante
struct Estudiante {
    string nombre;
    int edad;
    float promedio;
};

int main() {
    Estudiante alumna;

    alumna.nombre = "manuela";
    alumna.edad = 18;
    alumna.promedio = 17.4;

    cout << "Datos de la estudiante:" << endl;
    cout << "Nombre: " << alumna.nombre << endl;
    cout << "Edad: " << alumna.edad << endl;
    cout << "Promedio: " << alumna.promedio << endl;

    return 0;
}
```

### üñ• Salida esperada:

```
Datos de la estudiante:
Nombre: manuela 
Edad: 18
Promedio: 17.4
```



## üë• Tambi√©n puedes usar arreglos de estructuras

Si quieres guardar varios estudiantes:

```cpp
Estudiante clase[3];

clase[0].nombre = "Ana";
clase[1].nombre = "Luis";
clase[2].nombre = "Marcos";
```

### üîó PARTE 4: Estructuras de datos din√°micas


# Cap√≠tulo 12 ‚Äì Punteros: direcciones y memoria

## üìå ¬øQu√© es un puntero?

Un **puntero** en C++ es una variable especial que guarda la **direcci√≥n de memoria** de otra variable. Es como si en vez de guardar un n√∫mero directamente, guardara un "mapa" que te dice d√≥nde encontrar ese n√∫mero.


## üß† ¬øPor qu√© son importantes?

Los punteros permiten:

* Compartir datos entre funciones sin copiarlos.
* Acceder y modificar datos directamente en memoria.
* Crear estructuras din√°micas como listas o √°rboles.
* Usar arreglos de forma m√°s eficiente.



## üì¶ ¬øC√≥mo se declara y se usa un puntero?

### üß™ Ejemplo con explicaci√≥n paso a paso

```cpp
#include <iostream> // Importa la librer√≠a para usar cout
using namespace std;

int main() {
    int edad = 18; // Creamos una variable llamada 'edad' con valor 18

    int* puntero = &edad; 
    // Creamos un puntero a entero llamado 'puntero'
    // Lo igualamos a la direcci√≥n de memoria de 'edad' usando '&'

    cout << "Valor de edad: " << edad << endl; 
    // Imprime el valor de la variable normalmente

    cout << "Direcci√≥n de memoria de edad: " << &edad << endl; 
    // Imprime la direcci√≥n de memoria de la variable

    cout << "Valor almacenado en puntero: " << puntero << endl; 
    // Imprime lo que contiene el puntero, o sea, la direcci√≥n de memoria

    cout << "Valor al que apunta el puntero: " << *puntero << endl; 
    // Imprime el valor que est√° en la direcci√≥n que guarda el puntero (18)

    return 0;
}
```



## üîÅ ¬øQu√© hacen los s√≠mbolos `&` y `*`?

| S√≠mbolo | Nombre                    | ¬øQu√© hace?                                                    |
| ------- | ------------------------- | ------------------------------------------------------------- |
| `&`     | Operador de direcci√≥n     | Obtiene la direcci√≥n de memoria de una variable (`&edad`)     |
| `*`     | Operador de desreferencia | Accede al valor almacenado en una direcci√≥n de memoria (`*p`) |



## üõ† ¬øD√≥nde se usan los punteros?

### ‚úîÔ∏è En funciones (para modificar valores desde fuera):

```cpp
void duplicar(int* numero) {
    *numero = *numero * 2;
}
```

* Se pasa la direcci√≥n de la variable.
* Se usa `*` para modificar el valor original.

### ‚úîÔ∏è En arreglos:

```cpp
int numeros[] = {10, 20, 30};
int* p = numeros;

cout << *p << endl;     // Muestra el primer n√∫mero: 10
cout << *(p + 1) << endl; // Muestra el segundo n√∫mero: 20
```

### ‚úîÔ∏è Para reservar memoria din√°mica:

```cpp
int* edad = new int; // Reservamos espacio para un entero en memoria
*edad = 25;          // Asignamos el valor 25 a esa direcci√≥n
delete edad;         // Liberamos la memoria
```



## üîç Cuadro 

| Acci√≥n                    | C√≥digo         | Explicaci√≥n                              |
| ------------------------- | -------------- | ---------------------------------------- |
| Declarar puntero          | `int* p;`      | Un puntero que guarda direcci√≥n de int   |
| Apuntar a una variable    | `p = &x;`      | Guarda la direcci√≥n de `x`               |
| Leer valor apuntado       | `*p`           | Accede al valor de la direcci√≥n guardada |
| Reservar memoria din√°mica | `p = new int;` | Crea un nuevo espacio de memoria         |
| Liberar memoria           | `delete p;`    | Libera el espacio reservado              |






# Cap√≠tulo 13 ‚Äì Listas enlazadas 

## üß† ¬øQu√© es una lista enlazada ?

Una **lista enlazada simple** es una estructura de datos din√°mica en la que cada **elemento (nodo)** contiene:

1. Un **dato**.
2. Un **puntero** que apunta al siguiente nodo de la lista.

üí° A diferencia de los arreglos, no se necesita saber cu√°ntos elementos tendr√° la lista al inicio. Se puede **agregar o quitar nodos f√°cilmente** durante la ejecuci√≥n.



## üß± ¬øC√≥mo est√° compuesta?

Cada nodo tiene esta forma:

```cpp
struct Nodo {
    int dato;         // Informaci√≥n que guarda
    Nodo* siguiente;  // Apunta al siguiente nodo
};
```

> üîÅ El √∫ltimo nodo siempre apunta a `NULL`, lo que indica el fin de la lista.



## ‚úèÔ∏è Crear y recorrer una lista enlazada simple (ejemplo completo)

```cpp
#include <iostream>
using namespace std;

// Estructura de un nodo
struct Nodo {
    int dato;
    Nodo* siguiente;
};

int main() {
    // Creamos tres nodos
    Nodo* primero = new Nodo();
    Nodo* segundo = new Nodo();
    Nodo* tercero = new Nodo();

    // Asignamos datos
    primero->dato = 10;
    segundo->dato = 20;
    tercero->dato = 30;

    // Enlazamos los nodos
    primero->siguiente = segundo;
    segundo->siguiente = tercero;
    tercero->siguiente = NULL; // Fin de la lista

    // Recorremos la lista
    Nodo* actual = primero;
    while (actual != NULL) {
        cout << actual->dato << " -> ";
        actual = actual->siguiente;
    }
    cout << "NULL" << endl;

    return 0;
}
```

### üîé ¬øQu√© hace este programa?

1. Crea tres nodos din√°micamente.
2. Guarda los valores `10`, `20` y `30`.
3. Enlaza los nodos uno tras otro.
4. Recorre la lista y muestra:
   `10 -> 20 -> 30 -> NULL`



## üõ† Operaciones b√°sicas con listas enlazadas

| Operaci√≥n          | ¬øQu√© hace?                           |
| ------------------ | ------------------------------------ |
| Insertar al inicio | Agrega un nuevo nodo al principio    |
| Insertar al final  | Agrega un nuevo nodo al final        |
| Eliminar un nodo   | Borra un nodo espec√≠fico             |
| Recorrer la lista  | Muestra todos los datos              |
| Buscar un elemento | Verifica si un dato est√° en la lista |



## üß™ Ejemplo: Insertar al inicio

```cpp
Nodo* nuevo = new Nodo();
nuevo->dato = 5;
nuevo->siguiente = primero;
primero = nuevo;
```

> üîÑ Ahora el nodo con valor `5` es el primero de la lista.



## üìä Visualizaci√≥n

```
[dato | siguiente] ‚Üí [dato | siguiente] ‚Üí [dato | NULL]
   10      ‚ü∂           20      ‚ü∂          30
```




# Cap√≠tulo 14 ‚Äì Listas doblemente enlazadas

## üß† ¬øQu√© es una lista doblemente enlazada?

Una **lista doblemente enlazada** es una estructura de datos din√°mica donde **cada nodo tiene tres partes**:

1. Un **dato**.
2. Un **puntero al nodo anterior**.
3. Un **puntero al nodo siguiente**.

üîÅ Esto permite **recorrer la lista en ambas direcciones** (hacia adelante y hacia atr√°s), a diferencia de la lista simple que solo va en un sentido.



## üß± Estructura de un nodo

```cpp
struct Nodo {
    int dato;
    Nodo* anterior;
    Nodo* siguiente;
};
```

> El primer nodo tiene `anterior = NULL`
> El √∫ltimo nodo tiene `siguiente = NULL`



## ‚úèÔ∏è Ejemplo: Crear y recorrer una lista doblemente enlazada

```cpp
#include <iostream>
using namespace std;

// Definici√≥n del nodo
struct Nodo {
    int dato;
    Nodo* anterior;
    Nodo* siguiente;
};

int main() {
    // Crear tres nodos
    Nodo* primero = new Nodo();
    Nodo* segundo = new Nodo();
    Nodo* tercero = new Nodo();

    // Asignar valores
    primero->dato = 10;
    segundo->dato = 20;
    tercero->dato = 30;

    // Enlazar hacia adelante
    primero->siguiente = segundo;
    segundo->siguiente = tercero;
    tercero->siguiente = NULL;

    // Enlazar hacia atr√°s
    primero->anterior = NULL;
    segundo->anterior = primero;
    tercero->anterior = segundo;

    // Recorrer hacia adelante
    cout << "Recorrido hacia adelante: ";
    Nodo* actual = primero;
    while (actual != NULL) {
        cout << actual->dato << " <-> ";
        actual = actual->siguiente;
    }
    cout << "NULL" << endl;

    // Recorrer hacia atr√°s
    cout << "Recorrido hacia atr√°s: ";
    actual = tercero;
    while (actual != NULL) {
        cout << actual->dato << " <-> ";
        actual = actual->anterior;
    }
    cout << "NULL" << endl;

    return 0;
}
```

### üîé ¬øQu√© hace este c√≥digo?

1. Crea tres nodos din√°micamente con los datos `10`, `20`, `30`.
2. Los enlaza hacia adelante (`siguiente`) y hacia atr√°s (`anterior`).
3. Muestra los valores desde el primero al √∫ltimo y luego en orden inverso.



## üìä Visualizaci√≥n

```
NULL ‚Üê [10] ‚áÑ [20] ‚áÑ [30] ‚Üí NULL
```



## ‚öôÔ∏è ¬øD√≥nde se usan las listas doblemente enlazadas?

Se usan cuando necesitas:

* Recorrer datos en ambos sentidos.
* Insertar o eliminar elementos tanto al inicio como al final.
* Implementar **navegadores (bot√≥n atr√°s/adelante)**, **listas de reproducci√≥n**, **editores de texto**, etc.



-

# Cap√≠tulo 15 ‚Äì Listas circulares

## üîÑ ¬øQu√© es una lista circular?

Una **lista circular** es una estructura de datos enlazada donde el **√∫ltimo nodo apunta al primero**, formando un ciclo cerrado.

üìå Puede ser:

* **Simplemente circular**: cada nodo tiene un puntero al siguiente, y el √∫ltimo apunta al primero.
* **Doblemente circular**: cada nodo tiene punteros al anterior y al siguiente, y est√°n conectados en ambos sentidos.



## üß† ¬øPara qu√© sirve una lista circular?

Las listas circulares se usan cuando:

* Necesitas recorrer una lista sin volver a empezar manualmente.
* Quieres un **acceso continuo o c√≠clico** (por ejemplo, turnos de jugadores, men√∫s circulares, etc.).



## üß± Estructura de un nodo (simplemente enlazada)

```cpp
struct Nodo {
    int dato;
    Nodo* siguiente;
};
```



## ‚úèÔ∏è Ejemplo: Crear una lista circular con 3 nodos

```cpp
#include <iostream>
using namespace std;

struct Nodo {
    int dato;
    Nodo* siguiente;
};

int main() {
    Nodo* primero = new Nodo();
    Nodo* segundo = new Nodo();
    Nodo* tercero = new Nodo();

    primero->dato = 10;
    segundo->dato = 20;
    tercero->dato = 30;

    // Enlazar los nodos
    primero->siguiente = segundo;
    segundo->siguiente = tercero;
    tercero->siguiente = primero;  // Cierra el ciclo

    // Recorrer la lista circular (una vuelta)
    Nodo* actual = primero;
    cout << "Recorrido circular: ";
    do {
        cout << actual->dato << " -> ";
        actual = actual->siguiente;
    } while (actual != primero);
    cout << "(vuelve al inicio)" << endl;

    return 0;
}
```



## üîç ¬øQu√© hace este c√≥digo?

* Crea tres nodos.
* Los enlaza formando un **ciclo**.
* Usa un bucle `do-while` para recorrerlos **una sola vuelta completa**, porque siempre se regresa al inicio.



## üéØ Visualizaci√≥n

```
[10] ‚Üí [20] ‚Üí [30]
 ‚Üë               ‚Üì
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üìö PARTE 5: Pilas, colas y recursi√≥n



# Cap√≠tulo 16 ‚Äì Pilas (Stacks): √öltimo en entrar, primero en salir

## üß† ¬øQu√© es un *stack*?

Un **stack** (en espa√±ol, *pila*) es una estructura de datos que funciona como una **torre de objetos**: lo √∫ltimo que colocas es lo primero que se retira.

A esto se le llama principio **LIFO** (*Last In, First Out*), es decir, **el √∫ltimo en entrar es el primero en salir**.

### üì¶ Ejemplo cotidiano:

Imagina una pila de platos:

1. Pones un plato sobre otro ‚Üí `push()`
2. Para sacar un plato, solo puedes sacar el de arriba ‚Üí `pop()`

No puedes sacar el de abajo sin antes quitar los de arriba.

---

## üìç ¬øPara qu√© sirve un stack?

Los *stacks* son √∫tiles en muchas situaciones, por ejemplo:

* Para **deshacer acciones** (como cuando haces CTRL+Z en Word).
* Para **navegar entre p√°ginas web** (bot√≥n "Atr√°s").
* En **resoluci√≥n de operaciones matem√°ticas** o **recursividad**.
* Para **gestionar llamadas de funciones** en un programa.

---

## ‚öôÔ∏è Operaciones b√°sicas de un stack

| Operaci√≥n | ¬øQu√© hace?                                     |
| --------- | ---------------------------------------------- |
| `push()`  | Agrega un nuevo elemento a la pila             |
| `pop()`   | Elimina el elemento que est√° arriba            |
| `top()`   | Muestra el elemento en la cima, sin eliminarlo |
| `empty()` | Verifica si la pila est√° vac√≠a                 |

---

## üíª Ejemplo en C++

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> pila;

    pila.push(10);  // Agregamos 10
    pila.push(20);  // Ahora 20 est√° arriba
    pila.push(30);  // 30 es el tope

    cout << "Elemento en la cima: " << pila.top() << endl;  // Muestra 30

    pila.pop();  // Quitamos el 30

    cout << "Nuevo tope: " << pila.top() << endl;  // Muestra 20

    return 0;
}
```

---

## üîç ¬øC√≥mo se ve internamente?

Antes del `pop()`:

```
[30] <- top
[20]
[10]
```

Despu√©s del `pop()`:

```
[20] <- top
[10]
```



# üìò Cap√≠tulo 17 ‚Äì Colas (Queues): Primero en entrar, primero en salir

## üß† ¬øQu√© es una cola?

Una **cola (queue)** es una estructura de datos lineal que funciona igual que una **fila de personas esperando en un lugar**.

üìå **Regla principal**:

> El primero que llega es el primero que se va.
> Esto se llama **FIFO** (*First In, First Out*).



## üè´ Ejemplo real

Imagina que est√°s en una tienda:

1. Llega Ana
2. Luego llega Luis
3. Despu√©s Mar√≠a

Entonces, el orden para ser atendidos es:

1. Ana
2. Luis
3. Mar√≠a

As√≠ funciona una cola en programaci√≥n. No puedes atender a Mar√≠a antes que a Ana, porque **Mar√≠a est√° al final**.



## üì¶ ¬øPara qu√© se usa una cola en programaci√≥n?

Las colas se usan cuando los datos deben **mantener su orden de entrada**. Algunos ejemplos:

üîπ **Impresoras**: si mandas varios documentos a imprimir, la impresora los toma uno por uno en el orden en que llegaron.

üîπ **Mensajes**: en aplicaciones como WhatsApp, los mensajes se reciben y procesan en orden.

üîπ **Inteligencia artificial**: para controlar turnos o movimientos en juegos.

üîπ **Sistemas operativos**: para manejar procesos o tareas pendientes.



## üõ†Ô∏è Operaciones b√°sicas

En C++ usamos la librer√≠a `#include <queue>` para trabajar con colas. Estas son las funciones m√°s comunes:

| Funci√≥n   | ¬øQu√© hace?                                     |
| --------- | ---------------------------------------------- |
| `push(x)` | Agrega el elemento `x` al final                |
| `pop()`   | Elimina el elemento del frente                 |
| `front()` | Muestra el elemento al frente (sin eliminarlo) |
| `empty()` | Devuelve `true` si la cola est√° vac√≠a          |
| `size()`  | Devuelve cu√°ntos elementos hay                 |



## üíª C√≥digo explicado paso a paso

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<string> cola;

    cola.push("Ana");     // Ana entra
    cola.push("Luis");    // Luis entra
    cola.push("Mar√≠a");   // Mar√≠a entra

    cout << "Frente de la cola: " << cola.front() << endl;  // Muestra "Ana"

    cola.pop();  // Ana sale de la cola

    cout << "Nuevo frente: " << cola.front() << endl;       // Muestra "Luis"

    return 0;
}
```

### ¬øQu√© pasa internamente?

üîπ Despu√©s del `push()`:

```
Frente --> [Ana] [Luis] [Mar√≠a] <-- Final
```

üîπ Despu√©s del `pop()`:

```
Frente --> [Luis] [Mar√≠a] <-- Final
```

Solo puedes acceder y eliminar al elemento del **frente**, no al del medio o final directamente.






# üìò Cap√≠tulo 18 ‚Äì Colas circulares

## üß† ¬øQu√© es una cola circular?

Una **cola circular** es una estructura de datos muy parecida a una cola normal (como una fila en el banco), pero con una mejora: **cuando llegas al final, puedes volver al inicio**.

> ‚ú® Imagina que la cola est√° dibujada en un c√≠rculo, por eso se llama "circular".

### üéØ ¬øPor qu√© usar una cola circular?

Porque en una **cola normal** (lineal), cuando se llenan los espacios del arreglo y eliminas elementos del frente, **ya no puedes usar ese espacio libre al principio**, aunque est√© vac√≠o.

Con una **cola circular**, s√≠ puedes volver a usar esos espacios vac√≠os. ¬°Aprovechas todo el espacio disponible!



## üîÅ Ejemplo visual

Sup√≥n que tienes una cola de 5 espacios:

```
[ _ ][ _ ][ _ ][ _ ][ _ ]   ‚Üê Capacidad: 5
```

Agregas tres n√∫meros:

```
[ 10 ][ 20 ][ 30 ][ _ ][ _ ]
```

Sacas dos elementos del inicio:

```
[ _ ][ _ ][ 30 ][ _ ][ _ ]
         ‚Üë
       frente
```

En una cola normal, ya no puedes usar los espacios vac√≠os del inicio.
‚ùå ¬°Desperdicio de memoria!

Pero en una **cola circular**, puedes volver al inicio:

```
[ 40 ][ 50 ][ 30 ][ _ ][ _ ]
```

‚úÖ ¬°Se aprovecha todo el arreglo!



## üí° ¬øD√≥nde se usan las colas circulares?

* En **buffers** de audio o video (como en YouTube).
* En **impresoras**, que guardan trabajos en cola.
* En **sistemas operativos**, para procesar tareas en orden.
* En **microcontroladores**, donde hay poca memoria.


## üíª Ejemplo simple en C++

```cpp
#include <iostream>
#define TAM 5

using namespace std;

class ColaCircular {
private:
    int cola[TAM];
    int frente, final, cantidad;

public:
    ColaCircular() {
        frente = 0;
        final = -1;
        cantidad = 0;
    }

    void encolar(int valor) {
        if (cantidad == TAM) {
            cout << "‚ö†Ô∏è La cola est√° llena\n";
            return;
        }
        final = (final + 1) % TAM;
        cola[final] = valor;
        cantidad++;
    }

    void desencolar() {
        if (cantidad == 0) {
            cout << "‚ö†Ô∏è La cola est√° vac√≠a\n";
            return;
        }
        frente = (frente + 1) % TAM;
        cantidad--;
    }

    void mostrar() {
        cout << "üìã Elementos en la cola: ";
        for (int i = 0; i < cantidad; i++) {
            int indice = (frente + i) % TAM;
            cout << cola[indice] << " ";
        }
        cout << endl;
    }
};

int main() {
    ColaCircular cola;
    cola.encolar(10);
    cola.encolar(20);
    cola.encolar(30);
    cola.desencolar();   // Sale el 10
    cola.encolar(40);
    cola.encolar(50);
    cola.encolar(60);    // No se puede: cola llena
    cola.mostrar();      // Muestra los elementos actuales
    return 0;
}
```


## üìù ¬øQu√© hace este programa?

1. Crea una cola circular de tama√±o 5.
2. Agrega 3 elementos: `10`, `20`, `30`.
3. Quita uno (sale el `10`).
4. Agrega otros valores y reutiliza los espacios del inicio.
5. Muestra lo que hay en la cola.



# üìò Cap√≠tulo 19 ‚Äì Recursi√≥n: funciones que se llaman a s√≠ mismas

## üß† ¬øQu√© es la recursi√≥n?

La recursi√≥n es una t√©cnica en programaci√≥n donde una funci√≥n se llama a s√≠ misma para resolver un problema paso a paso, resolviendo primero los casos m√°s simples.

Es como cuando te miras en un espejo frente a otro: la imagen se repite una y otra vez, cada vez m√°s peque√±a. As√≠ funciona una funci√≥n recursiva: se repite dentro de s√≠ misma hasta llegar a una soluci√≥n.


## üì¶ ¬øPara qu√© sirve?

La recursi√≥n es √∫til cuando un problema se puede **dividir en partes m√°s peque√±as** que son similares al problema original. Por ejemplo:

* Calcular el **factorial** de un n√∫mero
* Generar la **serie Fibonacci**
* Buscar datos en estructuras como **√°rboles**
* Resolver problemas que siguen un **patr√≥n repetitivo**



## üß© ¬øC√≥mo funciona una funci√≥n recursiva?

Una funci√≥n recursiva **debe tener siempre dos partes**:

1. üî¥ **Caso base** ‚Üí cuando se debe detener la repetici√≥n.
2. üîÅ **Llamada recursiva** ‚Üí la funci√≥n se llama a s√≠ misma con un valor m√°s peque√±o o modificado.

> Si no hay un caso base, la funci√≥n se ejecutar√° infinitamente y causar√° errores (¬°mucho cuidado!).



## üß™ Ejemplo 1: Factorial de un n√∫mero

El **factorial** de un n√∫mero `n` (n!) se calcula as√≠:

```
5! = 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120
```

### üîß C√≥digo en C++:

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0)  // caso base
        return 1;
    else
        return n * factorial(n - 1);  // llamada recursiva
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es: " << factorial(numero);
    return 0;
}
```

### üß† ¬øQu√© pasa aqu√≠?

* `factorial(5)` necesita el resultado de `factorial(4)`
* `factorial(4)` necesita el resultado de `factorial(3)`
* ...
* Hasta llegar a `factorial(0)` que devuelve `1`, y desde ah√≠ se resuelven todas las operaciones.



## üß™ Ejemplo 2: Serie Fibonacci

La **serie Fibonacci** es una secuencia de n√∫meros donde cada n√∫mero es la suma de los dos anteriores:

```
0, 1, 1, 2, 3, 5, 8, 13, ...
```

### üîß C√≥digo en C++:

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n == 0) return 0;       // caso base
    if (n == 1) return 1;       // caso base
    return fibonacci(n - 1) + fibonacci(n - 2);  // llamada recursiva
}

int main() {
    int numero = 6;
    cout << "Fibonacci de " << numero << " es: " << fibonacci(numero);
    return 0;
}
```





